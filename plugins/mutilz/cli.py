"""
cli for generating mutilz actions.
"""

import argparse
import datetime
import sys
from pathlib import Path
from string import Template

from mutilz.inflectionator import camel_to_snake, camelize, titleize

ACTION_TEMPLATE = Template(
    r"""# generated by mutilz cli at ${timestamp}
import dataclasses
import functools
import logging
import time
import typing

import ida_bytes
import ida_funcs
import ida_kernwin
import ida_segment
import ida_ua
import idaapi
import idautils
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers


logger = logging.getLogger("${category}.actions.${snake_name}")


def execute_action(start_ea: int, end_ea: int):
    print(f"Hello! Called execute_action with range 0x{start_ea:X} - 0x{end_ea:X}")
    

@dataclasses.dataclass
class ${camel_name}ActionHandler(ida_helpers.BaseActionHandler):
${action_doc}
    action_name: str = "${category}:${snake_name}"
    action_label: str = "${action_label}"
    icon: int = ${icon}

    def get_selected_addresses(self, ctx):
        is_selected, start_ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if is_selected:
            return start_ea, end_ea

        # maybe it's the same line?
        p0, p1 = ida_kernwin.twinpos_t(), ida_kernwin.twinpos_t()
        ida_kernwin.read_selection(ctx.widget, p0, p1)
        p0.place(ctx.widget)
        p1.place(ctx.widget)
        if p0.at and p1.at:
            start_ea = p0.at.toea()
            end_ea = p1.at.toea()
            if start_ea == end_ea:
                start_ea = idc.get_item_head(start_ea)
                end_ea = idc.get_item_end(start_ea)
                return start_ea, end_ea

        # if we are here, we haven't selected anything, so we use the current address
        start_ea = idaapi.get_screen_ea()
        try:
            end_ea = ida_kernwin.ask_addr(start_ea, "Enter end address for selection:")
        finally:
            # restore the cursor to the original address
            idc.jumpto(start_ea)

        if end_ea and end_ea <= start_ea:
            print(
                f"Error: End address 0x{end_ea:X} must be greater than start address 0x{start_ea:X}."
            )
            end_ea = None

        if end_ea is None:
            # if we canceled the dialog, let's assume the user wants
            # to select just the line they're on
            end_ea = idc.get_item_end(start_ea)
            print(f"No end address selected, using line end: 0x{end_ea:X}")

        return start_ea, end_ea
            
    def activate(self, ctx):
        curr_ea = idaapi.get_screen_ea()
        start_ea, end_ea = self.get_selected_addresses(ctx)
        try:
            execute_action(start_ea, end_ea)
        finally:
            idc.jumpto(curr_ea)

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class ${camel_name}Action(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        ${camel_name}ActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return ${camel_name}Action()

"""
)


def build_parser():
    parser = argparse.ArgumentParser(
        description="Mutilz CLI for generating action template files."
    )
    # Required positional argument for action_name.
    parser.add_argument(
        "action_name",
        type=str,
        help="Name of the action in CamelCase (e.g., ForceAnalyze)",
    )
    parser.add_argument(
        "--category",
        type=str,
        help="Category of the action (e.g., mutilz)",
        default="mutilz",
    )
    parser.add_argument(
        "--action-label",
        type=str,
        help="Label of the action. Defaults to titlized snake_case action name if not provided.",
        default=None,
    )
    parser.add_argument(
        "--icon",
        type=int,
        help="Icon id for the action (e.g., 171 for a lightning bolt icon)",
        default=171,
    )
    parser.add_argument(
        "--action-desc",
        type=str,
        help="Description of the action. Will be added as a docstring if provided.",
        default=None,
    )
    parser.add_argument(
        "--filename",
        type=str,
        help="File name for the new action template. If not provided, it is derived from the snake_case of the action name.",
        default=None,
    )
    parser.add_argument(
        "--outdir",
        type=str,
        help="Directory to create the action in. Defaults to the sibling 'actions' directory.",
        default=None,
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite the action if it already exists.",
        default=False,
    )
    return parser


def construct_target_file(args, snake_name: str) -> Path:
    """Determine the target file path based on the provided arguments."""
    if args.outdir is not None:
        outdir = Path(args.outdir)
    else:
        # Use the sibling "actions" directory relative to the CLI file.
        cli_dir = Path(__file__).resolve().parent
        outdir = cli_dir / "actions"

    # Ensure the output directory exists.
    outdir.mkdir(parents=True, exist_ok=True)

    # Determine the file name.
    if args.filename:
        file_name = (
            args.filename if args.filename.endswith(".py") else args.filename + ".py"
        )
    else:
        file_name = snake_name + ".py"
    target_file = outdir / file_name
    return target_file


def write_template(parser: argparse.ArgumentParser, argv: list[str]):
    """Writes the action template file based on the provided arguments."""
    args = parser.parse_args(argv)

    # Preserve original CamelCase for the class name.
    camel_name = camelize(args.action_name)
    snake_name = camel_to_snake(args.action_name)

    target_file = construct_target_file(args, snake_name)

    if not args.force and target_file.exists():
        parser.error(
            f"Action file already exists at: {target_file}, use --force to overwrite."
        )

    # Determine the action label, titlizing the snake_case name if not provided.
    action_label = titleize(snake_name) if not args.action_label else args.action_label
    action_doc = f'    """{args.action_desc if args.action_desc else action_label}"""'

    # Get the current timestamp.
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Substitute values into the template using string.Template.
    content = ACTION_TEMPLATE.substitute(
        camel_name=camel_name,
        snake_name=snake_name,
        category=args.category,
        action_label=action_label,
        icon=args.icon,
        action_doc=action_doc,
        timestamp=timestamp,
    )

    # Write the template out to the target file.
    with target_file.open("w", encoding="utf-8") as f:
        f.write(content)
    print(f"Template action file created at: {target_file}")


def main(argv: list[str]):
    parser = build_parser()
    write_template(parser, argv)


if __name__ == "__main__":
    main(sys.argv[1:])
