# generated by mutilz cli at 2025-03-29 13:51:16
import dataclasses
import functools
import logging
import time
import typing

import ida_bytes
import ida_funcs
import ida_kernwin
import ida_segment
import ida_ua
import idaapi
import idautils
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers

logger = logging.getLogger("mutilz.actions.jump_to_func_end")


def execute_action(current_ea: int):
    # get the function end ea
    func = ida_funcs.get_func(current_ea)
    if func is None or getattr(func, "end_ea", idaapi.BADADDR) == idaapi.BADADDR:
        print("No function found at current address.")
        return
    # jump to the function end
    idc.jumpto(func.end_ea)


@dataclasses.dataclass
class JumptofuncendActionHandler(ida_helpers.BaseActionHandler):
    """Jump To Func End"""

    action_name: str = "mutilz:jump_to_func_end"
    action_label: str = "Jump To Func End"
    icon: int = 85

    def get_selected_addresses(self):
        is_selected, start_ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if is_selected and start_ea != idaapi.BADADDR and end_ea != idaapi.BADADDR:
            # reset ea to start_ea since we selected a range specifically to the
            # start and end of the range
            return start_ea, end_ea

        print("No range selected!")
        if not start_ea:
            start_ea = idaapi.get_screen_ea()
            print(
                f"Cannot determine start address, using current address: 0x{start_ea:X}"
            )
        end_ea = ida_kernwin.ask_addr(start_ea, "Enter end address for selection:")
        if end_ea is None:
            print("Selection canceled. Returning start address.")
            return start_ea, None
        if end_ea <= start_ea:
            print("Error: End address must be greater than start address.")
            return start_ea, None
        return start_ea, end_ea

    def activate(self, ctx):
        execute_action(idaapi.get_screen_ea())

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class JumptofuncendAction(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        JumptofuncendActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return JumptofuncendAction()
