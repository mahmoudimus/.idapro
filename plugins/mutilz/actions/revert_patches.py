# generated by mutilz cli at 2025-03-11 17:59:27
import dataclasses
import functools
import logging

import ida_auto
import ida_bytes
import ida_funcs
import ida_hexrays
import ida_kernwin
import ida_problems
import idaapi
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers

logger = logging.getLogger("mutilz.actions.revert_patches")


def revert_range(start_ea, end_ea, force_reset=False):
    """
    Revert all the modified bytes within the given address range.
    """

    # revert bytes to their original value within the target region
    for ea in range(start_ea, end_ea):
        ida_bytes.revert_byte(ea)

    if force_reset:
        # 'undefine' the reverted bytes (helps with re-analysis)
        length = end_ea - start_ea
        ida_bytes.del_items(start_ea, ida_bytes.DELIT_KEEPFUNC, length)

    #
    # if the reverted patch seems to be in a code-ish area, we tell the
    # auto-analyzer to try and analyze it as code
    #
    ida_auto.auto_mark_range(start_ea, end_ea, ida_auto.AU_CODE)

    # attempt to re-analyze the reverted region
    ida_auto.plan_and_wait(start_ea, end_ea, True)

    #
    # having just reverted the bytes to their original values on the IDA
    # side of things, we now have to ensure these addresses are no longer
    # tracked by our plugin as 'patched'
    #
    ida_kernwin.refresh_idaview_anyway()
    return True


@dataclasses.dataclass
class RevertpatchesActionHandler(ida_helpers.BaseActionHandler):
    """Revert Patches"""

    action_name: str = "mutilz:revert_patches"
    action_label: str = "Revert Patches"
    icon: int = 171

    def activate(self, ctx):
        is_selected, ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if not is_selected or (ea == idaapi.BADADDR or end_ea == idaapi.BADADDR):
            # if the current address is the start of a function, select the entire function
            ea = idaapi.get_screen_ea()
            func = ida_funcs.get_func(ea)
            if func and func.start_ea == ea:
                end_ea = func.end_ea
            else:
                # prompt the user for a range
                print("No range selected.")
                end_ea = ida_kernwin.ask_addr(ea, "Enter end address for selection:")
                if end_ea is None:
                    print("Selection cancelled.")
                    return
                if end_ea <= ea:
                    print("Error: End address must be greater than start address.")
                    return

        print(f"Selection start: 0x{ea:X}, end: 0x{end_ea:X} (user-defined)")

        try:
            revert_range(ea, end_ea, force_reset=False)
        finally:
            idc.jumpto(ea)

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class RevertpatchesAction(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        RevertpatchesActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return RevertpatchesAction()
