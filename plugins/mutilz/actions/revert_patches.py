# generated by mutilz cli at 2025-03-11 17:59:27
import dataclasses
import functools
import logging

import ida_auto
import ida_bytes
import ida_funcs
import ida_hexrays
import ida_kernwin
import ida_problems
import idaapi
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers

logger = logging.getLogger("mutilz.actions.revert_patches")


def revert_range(start_ea, end_ea):
    """
    Revert all the modified bytes within the given address range.
    """

    # revert bytes to their original value within the target region
    for ea in range(start_ea, end_ea):
        ida_bytes.revert_byte(ea)

    # 'undefine' the reverted bytes (helps with re-analysis)
    length = end_ea - start_ea
    ida_bytes.del_items(start_ea, ida_bytes.DELIT_KEEPFUNC, length)

    #
    # if the reverted patch seems to be in a code-ish area, we tell the
    # auto-analyzer to try and analyze it as code
    #

    if ida_bytes.is_code(ida_bytes.get_flags(ida_bytes.prev_head(start_ea, 0))):
        ida_auto.auto_mark_range(start_ea, end_ea, ida_auto.AU_CODE)

    # attempt to re-analyze the reverted region
    ida_auto.plan_and_wait(start_ea, end_ea, True)

    #
    # having just reverted the bytes to their original values on the IDA
    # side of things, we now have to ensure these addresses are no longer
    # tracked by our plugin as 'patched'
    #
    ida_kernwin.refresh_idaview_anyway()
    return True


@dataclasses.dataclass
class RevertpatchesActionHandler(ida_helpers.BaseActionHandler):
    """Revert Patches"""

    action_name: str = "mutilz:revert_patches"
    action_label: str = "Revert Patches"
    icon: int = 171

    def activate(self, ctx):
        is_selected, start_ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if is_selected and start_ea != idaapi.BADADDR and end_ea != idaapi.BADADDR:
            # reset ea to start_ea since we selected a range specifically to the
            # start and end of the range
            ea = start_ea
        else:
            start_ea = ea
            print("No range selected.")
            end_ea = ida_kernwin.ask_addr(start_ea, "Enter end address for selection:")
            if end_ea is None:
                print("Selection cancelled.")
                return
            if end_ea <= start_ea:
                print("Error: End address must be greater than start address.")
                return
        print(f"Selection start: 0x{start_ea:X}, end: 0x{end_ea:X} (user-defined)")

        try:
            revert_range(start_ea, end_ea)
        finally:
            idc.jumpto(ea)

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class RevertpatchesAction(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        RevertpatchesActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return RevertpatchesAction()
