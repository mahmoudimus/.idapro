# generated by mutilz cli at 2025-03-18 11:07:29
import dataclasses
import functools
import logging
import sys
import time
import typing

import ida_bytes
import ida_funcs
import ida_kernwin
import ida_segment
import ida_ua
import idaapi
import idautils
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers

logger = logging.getLogger("mutilz.actions.int3_patch")


try:
    import patching.util as patching_util

    patching = sys.modules["__main__"].patching
except ImportError:
    patching = None


def execute_action(start_ea: int, end_ea: int):
    print(f"Hello! Called execute_action with range 0x{start_ea:X} - 0x{end_ea:X}")
    range_size = end_ea - start_ea
    if range_size < 0:
        return

    # fetch the bytes for a CC instruction (and its size)
    cc_data = patching.core.assembler.asm("INT 3", start_ea)
    cc_size = len(cc_data)

    # generate a buffer of NOP's equal to the range we are filling in
    cc_buffer = cc_data * (range_size // cc_size)
    patching.core.patch(start_ea, cc_buffer, fill_nop=False)


@dataclasses.dataclass
class Int3PatchActionHandler(ida_helpers.BaseActionHandler):
    """Int3 Patch"""

    action_name: str = "mutilz:int3_patch"
    action_label: str = "INT3 Patch"
    icon: int = 171

    def get_selected_addresses(self, ctx):
        is_selected, start_ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if is_selected:
            return start_ea, end_ea

        # maybe it's the same line?
        p0, p1 = ida_kernwin.twinpos_t(), ida_kernwin.twinpos_t()
        range_selected = ida_kernwin.read_selection(ctx.widget, p0, p1)
        p0.place(ctx.widget)
        p1.place(ctx.widget)
        start_ea = p0.at.toea()
        end_ea = p1.at.toea()
        if start_ea == end_ea:
            start_ea = idc.get_item_head(start_ea)
            end_ea = idc.get_item_end(start_ea)
            return start_ea, end_ea

        print("No range selected!")
        if not start_ea:
            start_ea = idaapi.get_screen_ea()
            print(
                f"Cannot determine start address, using current address: 0x{start_ea:X}"
            )
        end_ea = ida_kernwin.ask_addr(start_ea, "Enter end address for selection:")
        if end_ea is None:
            print("Selection canceled. Returning start address.")
            return start_ea, None
        if end_ea <= start_ea:
            print("Error: End address must be greater than start address.")
            return start_ea, None
        return start_ea, end_ea

    def activate(self, ctx):
        curr_ea = idaapi.get_screen_ea()
        start_ea, end_ea = self.get_selected_addresses(ctx)
        try:
            if not end_ea:
                return
            execute_action(start_ea, end_ea)
        finally:
            idc.jumpto(curr_ea)

    def update(self, ctx):
        if not patching:
            return idaapi.AST_DISABLE_FOR_WIDGET

        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


def widget_populator(self: ida_helpers.PopUpHook, widget, popup, ctx):
    # print(f"widget_populator called with {widget}, {popup}, {ctx}")
    # print(f"patching: {patching}")
    # print(
    #     f"is_disassembly_widget: {ida_helpers.is_disassembly_widget(widget, popup, ctx)}"
    # )
    # print(f"get_widget_title: {ida_kernwin.get_widget_title(ctx.widget)}")
    if not patching or not any(
        [
            ida_helpers.is_disassembly_widget(widget, popup, ctx),
            ida_kernwin.get_widget_title(ctx.widget) == "PatchingCodeViewer",
        ]
    ):
        return

    p0, p1 = ida_kernwin.twinpos_t(), ida_kernwin.twinpos_t()
    range_selected = ida_kernwin.read_selection(widget, p0, p1)
    valid_ea, start_ea, end_ea = patching_util.ida.read_range_selection(ctx)
    if not valid_ea:
        start_ea = patching_util.ida.get_current_ea(ctx)

    if range_selected:
        if ida_segment.segtype(start_ea) == ida_segment.SEG_CODE:
            result = ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                Int3PatchActionHandler.action_label,
                "Analyze selected area",
                ida_kernwin.SETMENU_APP,
            )
        else:
            result = ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                Int3PatchActionHandler.action_label,
                "Abort selection",
                ida_kernwin.SETMENU_APP,
            )

    else:
        result = ida_kernwin.attach_action_to_popup(
            widget,
            popup,
            Int3PatchActionHandler.action_label,
            "Rename",
            ida_kernwin.SETMENU_APP,
        )

    print(
        f"widget_populator called, range_selected: {range_selected}, start_ea: {start_ea:X}, inserted? {result}"
    )


class Int3PatchAction(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook, Int3PatchActionHandler, ida_helpers.is_disassembly_widget
    )


# retrieve the action
def get_action() -> actions.action_t:
    return Int3PatchAction()
