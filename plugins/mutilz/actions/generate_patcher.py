# generated by mutilz cli at 2025-02-18 13:17:36
import dataclasses
import datetime
import functools
import string

import ida_kernwin
import ida_name
import idaapi
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers

# Main template for the generated patcher script including a placeholder for the patch block.
patcher_template = string.Template(
    r"""# generated @ ${timestamp}
#!/usr/bin/env python
# coding: UTF-8

import binascii
import os
import re
import sys

target_path = sys.argv[1]
target_data = None
with open(target_path, "rb") as target_file:
    target_data = binascii.hexlify(target_file.read()).decode("utf-8")

${patch_code}

result_path = f"{target_path}_patched"
with open(result_path, "wb") as result_file:
    if sys.version_info[0] >= 3:
        result_file.write(bytes.fromhex(target_data))
    else:
        result_file.write(target_data.decode("hex"))

print(f"Successfully generated patched binary to '{result_path}'")
"""
)

# Template for each individual patch block.
patch_block_template = string.Template(
    r"""# Patch at address: 0x$begin_addr
# Function name: $func_name
# Comment: $comment
matches = re.findall(r"$original", target_data)
if len(matches) == 1:
    target_data = target_data.replace(r"$original", r"$patched")
else:
    print("Patch pattern isn't unique")
    sys.exit(1)
"""
)


@dataclasses.dataclass
class GeneratepatcherActionHandler(ida_helpers.BaseActionHandler):
    """Generate Patcher"""

    action_name: str = "mutilz:generate_patcher"
    action_label: str = "Generate Patcher"
    icon: int = 339

    def activate(self, ctx):
        self.patched_bytes = []
        self.prev_addr = None
        return self.generate()

    def update(self, ctx):
        return (
            idaapi.AST_ENABLE_FOR_WIDGET
            if ctx.widget_type == idaapi.BWN_DISASM
            else idaapi.AST_DISABLE_FOR_WIDGET
        )

    def generate(self):
        idaapi.visit_patched_bytes(0, idaapi.BADADDR, self.get_patch_byte)
        if len(self.patched_bytes) == 0:
            msg = "Cannot generate patch because there is no patch applied."
            print(f"genpatch: {msg}")
            ida_kernwin.warning(msg)
            return False

        patch_blocks = []
        for data in self.patched_bytes:
            # Pre-format the address into a hex string.
            hex_addr = f"{data['begin_addr']:x}"
            block = patch_block_template.substitute(
                begin_addr=hex_addr,
                func_name=data["func_name"],
                comment=data["comment"],
                original=data["original"],
                patched=data["patched"],
            )
            patch_blocks.append(block)
        patch_code = "\n".join(patch_blocks)

        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        script_content = patcher_template.substitute(
            timestamp=timestamp, patch_code=patch_code
        )
        patch_path = idc.get_input_file_path() + "_patch.py"

        with open(patch_path, "w") as f:
            f.write(script_content)

        msg = f"Successfully generated patch to {patch_path} from Patched Bytes"
        print(f"genpatch: {msg}")
        ida_kernwin.info(msg)
        return 1

    # Callback passed to idaapi.visit_patched_bytes
    def get_patch_byte(self, ea, fpos, org_val, patched_val):
        org_byte = f"{org_val:02x}"
        patched_byte = f"{patched_val:02x}"

        if self.prev_addr is None or ea != (self.prev_addr + 1):
            func_name = idc.get_segm_name(ea)
            if idc.get_func_name(ea) or idc.get_name(ea, ida_name.GN_VISIBLE):
                func_name += ": "
                func_name += idc.get_func_name(ea)
                func_name += idc.get_name(ea, ida_name.GN_VISIBLE)

            comment = idc.get_cmt(ea, 0) or idc.get_cmt(ea, 1) or ""
            comment = comment.replace("\n", " ")

            self.patched_bytes.append(
                {
                    "func_name": func_name,
                    "begin_addr": ea,
                    "original": org_byte,
                    "patched": patched_byte,
                    "comment": comment,
                }
            )
        else:
            self.patched_bytes[-1]["original"] += org_byte
            self.patched_bytes[-1]["patched"] += patched_byte

        self.prev_addr = ea
        return 0


class GeneratepatcherAction(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        GeneratepatcherActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# Retrieve the action
def get_action() -> actions.action_t:
    return GeneratepatcherAction()
