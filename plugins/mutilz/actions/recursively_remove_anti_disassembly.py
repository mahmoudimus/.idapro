# generated by mutilz cli at 2025-03-29 14:47:22
import collections
import dataclasses
import functools
import itertools
import logging
import re
import struct
import typing
from dataclasses import dataclass, field
from enum import Enum, auto

import ida_allins
import ida_bytes
import ida_funcs
import ida_gdl
import ida_ida
import ida_kernwin
import ida_name
import ida_ua
import ida_xref
import idaapi
import idautils
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers
from mutilz.actions.remove_anti_disassembly import execute_action
from mutilz.helpers.ida import clear_output, format_addr
from mutilz.logconf import configure_debug_logging

logger = logging.getLogger("mutilz.actions.recursively_remove_anti_disassembly")


def demangle_name(name):
    """Demangle a function name."""
    demangled = ida_name.demangle_name(name, ida_name.MNG_SHORT_FORM)
    if demangled:
        # Remove any template parameters for file naming
        clean_name = re.sub(r"<.*>", "", demangled)
        return clean_name
    return name


def get_function_name(ea):
    """Get the demangled function name for a given address."""
    func_name = ida_name.get_ea_name(ea)
    return demangle_name(func_name)


def get_called_functions(func_ea):
    """Get addresses of all functions called within the specified function."""
    called_funcs = set()

    # Get the function
    func = ida_funcs.get_func(func_ea)
    if not func:
        return called_funcs

    # Get the function's flow chart
    flow_chart = ida_gdl.FlowChart(func)

    # Iterate through each basic block in the function
    for block in flow_chart:
        # Iterate through each instruction in the block
        ea = block.start_ea
        while ea < block.end_ea:
            # Check for code references from this address
            xref = ida_xref.xrefblk_t()
            if xref.first_from(ea, ida_xref.XREF_FAR):
                while True:
                    # If it's a code reference and it's a call, add it
                    if xref.type == ida_xref.fl_CN or xref.type == ida_xref.fl_CF:
                        target_func = ida_funcs.get_func(xref.to)
                        if target_func:
                            called_funcs.add(target_func.start_ea)

                    if not xref.next_from():
                        break

            # Move to the next instruction
            insn = ida_ua.insn_t()
            if ida_ua.decode_insn(insn, ea) == 0:
                ea += 1  # Fallback if decode fails
            else:
                ea += insn.size

    return called_funcs


def recursively_remove_anti_disassembly(
    start_func_ea, max_depth, visited=None, current_depth=0
):
    """Recursively decompile functions up to max_depth."""
    if visited is None:
        visited = set()

    if current_depth > max_depth or start_func_ea in visited:
        return {}

    # Mark this function as visited
    visited.add(start_func_ea)

    # Get function name
    func_name = get_function_name(start_func_ea)
    end_ea = ida_funcs.get_func(start_func_ea).end_ea

    # Decompile the function
    logger.info(
        f"Removing anti-disassembly from {hex(start_func_ea)} (depth {current_depth}/{max_depth})"
    )
    decompiled_code = execute_action(
        start_func_ea, end_ea, patch=True, force_analyze=True
    )

    # Get called functions
    called_funcs = get_called_functions(start_func_ea)

    # Initialize results
    result = {start_func_ea: (func_name, decompiled_code)}

    # Recursively process called functions
    for called_ea in called_funcs:
        if called_ea not in visited:
            # Only recurse if we haven't hit the depth limit
            if current_depth < max_depth:
                sub_results = recursively_remove_anti_disassembly(
                    called_ea, max_depth, visited, current_depth + 1
                )
                result.update(sub_results)

    return result


@dataclasses.dataclass
class RecursivelyRemoveAntiDisassemblyActionHandler(ida_helpers.BaseActionHandler):
    """Recursively Remove Anti Disassembly"""

    action_name: str = "mutilz:recursively_remove_anti_disassembly"
    action_label: str = "Recursively Remove Anti Disassembly"
    icon: int = 171

    def get_selected_addresses(self, ctx):
        is_selected, start_ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if is_selected:
            return start_ea, end_ea

        # maybe it's the same line?
        p0, p1 = ida_kernwin.twinpos_t(), ida_kernwin.twinpos_t()
        range_selected = ida_kernwin.read_selection(ctx.widget, p0, p1)
        p0.place(ctx.widget)
        p1.place(ctx.widget)
        if not p0.at or not p1.at:
            return idaapi.get_screen_ea(), None
        start_ea = p0.at.toea()
        end_ea = p1.at.toea()

        if start_ea == end_ea:
            start_ea = idc.get_item_head(start_ea)
            end_ea = idc.get_item_end(start_ea)
            return start_ea, end_ea

        print("No range selected!")
        if not start_ea:
            start_ea = idaapi.get_screen_ea()
            print(
                f"Cannot determine start address, using current address: 0x{start_ea:X}"
            )
        end_ea = ida_kernwin.ask_addr(start_ea, "Enter end address for selection:")
        if end_ea is None:
            print("Selection canceled. Returning start address.")
            return start_ea, None
        if end_ea <= start_ea:
            print("Error: End address must be greater than start address.")
            return start_ea, None
        return start_ea, end_ea

    def activate(self, ctx):
        curr_ea = idaapi.get_screen_ea()
        start_ea, end_ea = self.get_selected_addresses(ctx)
        try:
            recursively_remove_anti_disassembly(start_ea, max_depth=10)
        finally:
            idc.jumpto(curr_ea)

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class RecursivelyRemoveAntiDisassemblyAction(
    actions.action_t, metaclass=ida_helpers.HookedActionMeta
):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        RecursivelyRemoveAntiDisassemblyActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return RecursivelyRemoveAntiDisassemblyAction()
