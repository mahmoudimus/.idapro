# generated by mutilz cli at 2025-02-18 10:47:31
import dataclasses
import functools
import re
import time
import typing

import ida_funcs
import ida_kernwin
import ida_nalt
import ida_typeinf
import idaapi
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers

from plugins.mutilz.actions.force_analyze import ForceAnalyzeAction
from plugins.mutilz.actions.remove_junk import RemoveJunkAction


@dataclasses.dataclass
class AutoDeobfuscateActionHandler(ida_helpers.BaseActionHandler):
    """Auto Deobfuscate"""

    action_name: str = "mutilz:auto_deobfuscate"
    action_label: str = "Auto Deobfuscate"
    icon: int = 4

    def activate(self, ctx):
        ea = idaapi.get_screen_ea()
        func = ida_funcs.get_func(ea)
        if func:
            start_ea = func.start_ea
            end_ea = func.end_ea
        else:
            print("No function found at the current address.")
            end_ea = ida_kernwin.ask_addr(ea, "Enter end address")
            if end_ea is None:
                print("Analysis cancelled.")
                return 0
            start_ea = ea

        self.deobfuscate_function(start_ea, end_ea)
        return 1

    def update(self, ctx):
        return (
            idaapi.AST_ENABLE_FOR_WIDGET
            if ctx.widget_type == idaapi.BWN_DISASM
            else idaapi.AST_DISABLE_FOR_WIDGET
        )

    @classmethod
    def deobfuscate_function(cls, start_ea, end_ea):
        """Deobfuscates the function."""
        func: ida_funcs.func_t = idaapi.get_func(start_ea)
        if not func:
            print("Error: No function found at address.")
            return
        # Get function name and demangled name
        mangled_name = func.get_name()
        demangled_name = idc.demangle_name(
            mangled_name, idc.get_inf_attr(idc.INF_LONG_DN)
        )

        if demangled_name:
            new_type = cls.fix_return_type(start_ea, demangled_name)
            if new_type:
                print(f"Updated function type at 0x{start_ea:X} to: {new_type}")
        time.sleep(1)
        if not func.does_return():
            func.flags &= ~ida_funcs.FUNC_NORET
            ida_funcs.update_func(func)
            print(f"Unset 'does not return' flag for function at 0x{start_ea:X}")
        time.sleep(1)
        # Reanalyze and remove junk
        ForceAnalyzeAction.reanalyze_function(start_ea, end_ea)
        RemoveJunkAction.visit_and_patch(start_ea, end_ea)
        idaapi.auto_wait()
        if demangled_name:
            new_type = cls.fix_return_type(start_ea, demangled_name)
            if new_type:
                print(f"Updated function type at 0x{start_ea:X} to: {new_type}")
        time.sleep(1)

    @staticmethod
    def extract_return_type(demangled: str) -> str | None:
        """
        Extracts the return type from a demangled name.
        # With an access specifier.
        >>> demangled1 = "public: bool Fuc::Name(arg1type* arg, arg2type* arg2)"
        >>> extract_return_type(demangled1)  # Output: "bool"
        ... "bool"

        # Without an access specifier.
        >>> demangled2 = "bool Fuc::Name(arg1type* arg, arg2type* arg2)"
        >>> extract_return_type(demangled2)  # Output: "bool"
        ... "bool"

        # With a multi-word return type.
        >>> demangled3 = "public: unsigned long Fuc::Name(arg1type* arg, arg2type* arg2)"
        >>> extract_return_type(demangled3)  # Output: "unsigned long"
        ... "unsigned long"
        """
        # Get the part before the opening parenthesis.
        pre_paren = demangled.split("(")[0].strip()

        # Split the string into tokens.
        tokens = pre_paren.split()
        if not tokens or len(tokens) < 2:
            return (
                None  # not enough tokens to contain both return type and function name
            )

        # Optionally remove known access specifiers.
        access_specifiers = {"public:", "private:", "protected:"}
        tokens = [t for t in tokens if t not in access_specifiers]

        # The last token is the function name (possibly qualified), so remove it.
        if len(tokens) < 2:
            return None  # still not enough tokens after removing access specifiers
        return_type_tokens = tokens[:-1]

        # Join the remaining tokens to form the full return type.
        return " ".join(return_type_tokens)

    @classmethod
    def fix_return_type(cls, start_ea, demangled_name):
        """Extracts and updates the return type of a function if necessary."""
        return_type_from_demangled = cls.extract_return_type(demangled_name)

        # Get current function type
        func: ida_funcs.func_t = idaapi.get_func(start_ea)
        func_prototype: ida_typeinf.tinfo_t = typing.cast(
            ida_typeinf.tinfo_t, func.get_prototype()
        )
        if func_prototype:
            # Remove __noreturn if present
            func_type = str(func_prototype)
            if "__noreturn" in func_type:
                print(f"** Removing __noreturn from {func_type}!")
                func_type = func_type.replace("__noreturn", "")
            # Get return type from function type
            return_type_from_func = str(func_prototype.get_rettype())
            print(f"** return_type_from_func: {return_type_from_func}")
            print(f"** return_type_from_demangled: {return_type_from_demangled}")
            # Compare and update if necessary
            if return_type_from_demangled != return_type_from_func:

                new_type = func_type.replace(
                    return_type_from_func, return_type_from_demangled, 1
                )  # Replace only the first occurrence

                try:
                    if not set_type(start_ea, new_type):
                        print(
                            f"Failed to apply type with {new_type} at 0x{start_ea:X}.. trying again with {demangled_name}."
                        )
                        set_type(start_ea, demangled_name)
                    ida_funcs.set_func_cmt(
                        func, f";previous prototype: {new_type}", False
                    )
                    return new_type
                    # if not ida_typeinf.apply_tinfo(
                    #     start_ea,
                    #     ida_typeinf.tinfo_t(),
                    #     ida_typeinf.TINFO_DEFINITE,
                    # ):
                    #     parsed_type = idc.parse_decl(new_type, idc.PT_SILENT)
                    #     if not idc.apply_type(
                    #         start_ea, parsed_type, idc.TINFO_DEFINITE
                    #     ):
                    #         print(f"Re-trying to apply type at 0x{start_ea:X}")

                    #         idc.apply_type(start_ea, new_type, idc.TINFO_DEFINITE)
                    # ida_typeinf.apply_decl(
                    #     start_ea, new_type, ida_typeinf.TINFO_DEFINITE
                    # )
                except Exception as e:
                    print(f"Error processing function at 0x{start_ea:X}: {e}")

        return None


def set_type(ea, type_str):
    _type = idc.parse_decl(type_str, idc.PT_SILENT)
    return idc.apply_type(ea, _type, ida_typeinf.TINFO_DEFINITE)


def parse_mangled_method_name(mangled_name):
    demangled_name = idc.demangle_name(mangled_name, idc.get_inf_attr(idc.INF_LONG_DN))
    if not demangled_name:
        return None, None
    return re.match(r"(?:(.*)::)?(.*?)\(.*\)", demangled_name).groups()


# Functions below were copied from ida_medigate


def get_func_details(func_ea):
    tinfo = ida_typeinf.tinfo_t()
    ida_nalt.get_tinfo(tinfo, func_ea)
    if not tinfo.is_func():
        return None
    func_details = ida_typeinf.func_type_data_t()
    tinfo.get_func_details(func_details)
    return func_details


def apply_signature(ea, sig):
    name = idc.get_func_name(ea)
    ret, args = sig
    print("apply 0x%x %s", ea, name)
    decl = "{} {}({})".format(ret, name, args)
    # log(decl)
    prototype_details = idc.parse_decl(decl, idc.PT_SILENT)
    # idc.set_name(ea, name)
    idc.apply_type(ea, prototype_details)


class AutoDeobfuscateAction(actions.action_t, metaclass=ida_helpers.HookedActionMeta):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        AutoDeobfuscateActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return AutoDeobfuscateAction()
