# generated by mutilz cli at 2025-03-09 17:59:52
import dataclasses
import enum
import functools
import logging
import time
import typing
from dataclasses import dataclass

import capstone
import ida_allins
import ida_bytes
import ida_funcs
import ida_ida
import ida_kernwin
import ida_segment
import ida_ua
import idaapi
import idautils
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers
from mutilz.helpers.ida import format_addr, ida_tguidm, refresh_idaview

logger = logging.getLogger("mutilz.actions.deflow_opaque_predicates")

# Define opcodes based on typical protector behavior
JUMP_OPCODES = set(range(0x70, 0x80)) | {0xEB, 0xE9}  # Jumps (short, near, conditional)
JUNK_OPCODES = {
    0x80,
    0x81,
    0x83,
    0xC6,
    0xC7,
    0xF6,
    0xE8,
    0x68,
    0x6A,
}  # Common junk opcodes
BIG_INSTR_OPCODES = {
    0xC8,
    0x05,
    0x0D,
    0x15,
    0x1D,
    0x25,
    0x2D,
    0x35,
    0x3D,
    0x68,
    0xA0,
    0xA1,
    0xA2,
    0xA3,
    0xA9,
    0xB8,
    0xB9,
    0xBA,
    0xBB,
    0xBC,
    0xBD,
    0xBE,
    0xBF,
    0xE8,
    0xE9,
    0x69,
    0x81,
    0xC7,
    0xF7,
}  # Typical "big" instructions marking stub ends
MAX_STUB_SIZE = 129  # Maximum stub size in bytes
MIN_STUB_SIZE = 24  # Minimum stub size in bytes
# Register encodings for RAX (0), RCX (1), RDX (2), RBX (3), RBP (5), RSI (6), RDI (7)
REGISTER_FIELDS = [0, 1, 2, 3, 5, 6, 7]


# A global list to track discovered addresses
_already_discovered = set()


def monitored_iter(iterable, timeout=60, diagnostic=None):
    """
    Wraps an iterable or generator to monitor its iteration time.
    If processing takes longer than `timeout` seconds, prompts the user
    with optional diagnostic information.

    Parameters:
        iterable: An iterable or generator to be wrapped.
        timeout: Number of seconds to wait before prompting the user (default is 60).
        diagnostic: Optional diagnostic information.
            - If a string, it will be appended to the prompt.
            - If a callable, it is called with (index, item) and should return a string.

    Yields:
        Each item from the original iterable.

    Raises:
        StopIteration: If the user chooses not to continue.

    Example:

    >>> def sample_diagnostic(idx, item):
    >>>     return f"Processing item {idx}: {item}"
    >>>
    >>> # An example generator that yields numbers 0 to 9 with a delay.
    >>> def slow_generator():
    >>>     for i in range(10):
    >>>         time.sleep(10)  # simulate long processing
    >>>         yield i
    >>>
    >>> try:
    >>>     for number in monitored_iter(slow_generator(), timeout=15, diagnostic=sample_diagnostic):
    >>>         print(f"Got number: {number}")
    >>> except StopIteration as e:
    >>>     print(e)
    """
    t = time.time()
    asked = False
    for index, item in enumerate(iterable):
        # Check if the elapsed time exceeds the timeout
        if time.time() - t > timeout and not asked:
            message = "The process is taking too long."
            if diagnostic:
                # Allow diagnostic to be a callable or a string
                if callable(diagnostic):
                    message += " " + diagnostic(index, item)
                else:
                    message += " " + str(diagnostic)
            message += " Do you want to continue?"
            response = idc.ask_yn(1, message)
            asked = True  # Only ask once per timeout event
            if response != 1:
                raise StopIteration("Iteration aborted by the user.")
            else:
                t = time.time()  # Reset timer after confirmation
                asked = False
        yield item

def is_jump_instruction(ea):
    """Check if the address contains a jump instruction."""
    opcode = idc.get_bytes(ea, 1)[0]
    if opcode in JUMP_OPCODES:
        if opcode == 0x0F:  # Two-byte conditional jumps (0x0F 0x8X)
            next_byte = idc.get_bytes(ea + 1, 1)[0]
            return next_byte >= 0x80 and next_byte <= 0x8F
        return True
    return False


def get_jump_target(ea):
    """Calculate the jump target and instruction size."""
    target = idc.get_operand_value(ea, 0)
    size = idc.get_item_size(ea)
    return target, size


def is_junk_instruction(ea, buffer_end_ea):
    """Check if the instruction is likely junk based on opcode and register usage."""
    opcode = idc.get_bytes(ea, 1)[0]
    if opcode in JUNK_OPCODES:
        # For opcodes with ModR/M bytes, check register usage
        if opcode in {0x80, 0x81, 0x83, 0xC6, 0xC7, 0xF6} and ea + 1 < buffer_end_ea:
            modrm = idc.get_bytes(ea + 1, 1)[0]
            reg = (modrm >> 3) & 0x7  # Extract register field from ModR/M
            if reg in REGISTER_FIELDS:  # Matches Utils::Random::Register()
                return True
        # Simple junk instructions like PUSH imm or CALL
        elif opcode in {0x68, 0x6A, 0xE8}:
            return True
    return False


def is_junk_region(start_ea, end_ea, func_end_ea, threshold=0.5):
    """Determine if a region is mostly junk or undefined bytes."""
    ea = start_ea
    junk_count = 0
    total_bytes = end_ea - start_ea
    while ea < end_ea:
        if idc.is_code(idc.get_full_flags(ea)):
            if is_junk_instruction(ea, func_end_ea):
                junk_count += idc.get_item_size(ea)
        else:
            junk_count += 1  # Undefined bytes count as junk
        ea += idc.get_item_size(ea) or 1
    # Heuristic: >50% junk or undefined bytes
    return junk_count > total_bytes * threshold


def neutralize_stub(start_ea, end_ea):
    """Replace the stub with NOPs and redefine as code."""
    length = end_ea - start_ea
    print(f"Neutralizing stub at 0x{start_ea:x} - 0x{end_ea:x} ({length} bytes)")
    for ea in range(start_ea, end_ea):
        idc.patch_byte(ea, 0x90)  # NOP
    idc.del_items(start_ea, 0, length)
    idc.create_insn(start_ea)


def ends_with_big_instruction(ea, region_end):
    """Check if the region ends with a big instruction."""
    last_insn_ea = idc.prev_head(region_end, ea)
    if last_insn_ea < ea or last_insn_ea >= region_end:
        return False
    opcode = idc.get_bytes(last_insn_ea, 1)[0]
    return opcode in BIG_INSTR_OPCODES


def update_flag_state(flag_state, address):
    """Update the static flag state based on the instruction at the given address."""
    mnem = idc.print_insn_mnem(address)
    if not mnem:
        return flag_state
    mnem_lower = mnem.lower()

    # Instructions that do not affect flags
    if (
        mnem_lower in ("mov", "lea", "nop", "xchg")
        or mnem_lower.startswith("cmov")
        or mnem_lower.startswith("j")
    ):
        return flag_state

    # Instructions that clear CF and OF but may set ZF, SF, PF
    if mnem_lower in ("and", "or", "xor", "test"):
        if mnem_lower == "xor":
            # Special case: XOR reg, reg sets ZF=1, CF=0, OF=0, SF=0, PF=1
            op1 = idc.print_operand(address, 0)
            op2 = idc.print_operand(address, 1)
            if op1 == op2 and "reg" in op1:  # Check if operands are the same register
                return {"ZF": 1, "CF": 0, "OF": 0, "SF": 0, "PF": 1}
        # General case: CF=0, OF=0, others undetermined
        return {"CF": 0, "OF": 0}

    # Instructions that set specific flags
    if mnem_lower == "clc":
        new_state = flag_state.copy() if flag_state is not None else {}
        new_state["CF"] = 0
        return new_state
    elif mnem_lower == "stc":
        new_state = flag_state.copy() if flag_state is not None else {}
        new_state["CF"] = 1
        return new_state
    elif mnem_lower == "cmc":
        if flag_state and "CF" in flag_state:
            new_state = flag_state.copy()
            new_state["CF"] = 1 - flag_state["CF"]
            return new_state
        return flag_state  # CF state unknown

    # Shift instructions: if shift count is 0, flags unchanged; else undetermined
    if mnem_lower in ("sal", "shl", "sar", "shr", "rol", "ror", "rcl", "rcr"):
        count = idc.get_operand_value(address, 1)
        if count == 0:
            return flag_state
        return None

    # Arithmetic instructions that affect all flags
    if mnem_lower in ("add", "sub", "cmp"):
        return None

    # For any other instruction, assume flags become undetermined
    return None


def static_evaluate_jcc_condition(flag_state, mnem):
    """Evaluate a conditional jump instruction statically using flag_state.
    Returns True if the condition is deterministically met, False if not met, or None if unknown.
    Handles all standard Jcc instructions based on ZF, CF, OF, SF, and PF."""
    if flag_state is None:
        return None
    mnem_lower = mnem.lower()

    # Helper function to check if all required flags are present
    def has_flags(*flags):
        return all(flag in flag_state for flag in flags)

    # Jump if overflow (OF == 1)
    if mnem_lower == "jo":
        if has_flags("OF"):
            return flag_state["OF"] == 1
        return None
    # Jump if no overflow (OF == 0)
    elif mnem_lower == "jno":
        if has_flags("OF"):
            return flag_state["OF"] == 0
        return None
    # Jump if carry / below (CF == 1)
    elif mnem_lower in ("jb", "jc", "jnae"):
        if has_flags("CF"):
            return flag_state["CF"] == 1
        return None
    # Jump if no carry / above or equal (CF == 0)
    elif mnem_lower in ("jae", "jnc", "jnb"):
        if has_flags("CF"):
            return flag_state["CF"] == 0
        return None
    # Jump if zero / equal (ZF == 1)
    elif mnem_lower in ("je", "jz"):
        if has_flags("ZF"):
            return flag_state["ZF"] == 1
        return None
    # Jump if not zero / not equal (ZF == 0)
    elif mnem_lower in ("jne", "jnz"):
        if has_flags("ZF"):
            return flag_state["ZF"] == 0
        return None
    # Jump if below or equal (CF == 1 or ZF == 1)
    elif mnem_lower in ("jbe", "jna"):
        if has_flags("CF", "ZF"):
            return flag_state["CF"] == 1 or flag_state["ZF"] == 1
        return None
    # Jump if above (CF == 0 and ZF == 0)
    elif mnem_lower in ("ja", "jnbe"):
        if has_flags("CF", "ZF"):
            return flag_state["CF"] == 0 and flag_state["ZF"] == 0
        return None
    # Jump if sign (SF == 1)
    elif mnem_lower == "js":
        if has_flags("SF"):
            return flag_state["SF"] == 1
        return None
    # Jump if no sign (SF == 0)
    elif mnem_lower == "jns":
        if has_flags("SF"):
            return flag_state["SF"] == 0
        return None
    # Jump if parity even (PF == 1)
    elif mnem_lower in ("jp", "jpe"):
        if has_flags("PF"):
            return flag_state["PF"] == 1
        return None
    # Jump if parity odd (PF == 0)
    elif mnem_lower in ("jnp", "jpo"):
        if has_flags("PF"):
            return flag_state["PF"] == 0
        return None
    # Jump if less (SF != OF)
    elif mnem_lower in ("jl", "jnge"):
        if has_flags("SF", "OF"):
            return flag_state["SF"] != flag_state["OF"]
        return None
    # Jump if greater or equal (SF == OF)
    elif mnem_lower in ("jge", "jnl"):
        if has_flags("SF", "OF"):
            return flag_state["SF"] == flag_state["OF"]
        return None
    # Jump if less or equal ((SF != OF) or ZF == 1)
    elif mnem_lower in ("jle", "jng"):
        if has_flags("SF", "OF", "ZF"):
            return (flag_state["SF"] != flag_state["OF"]) or flag_state["ZF"] == 1
        return None
    # Jump if greater ((SF == OF) and ZF == 0)
    elif mnem_lower in ("jg", "jnle"):
        if has_flags("SF", "OF", "ZF"):
            return (flag_state["SF"] == flag_state["OF"]) and flag_state["ZF"] == 0
        return None
    # Unsupported or unrecognized Jcc mnemonic
    else:
        return None


def get_function_blocks(f: idaapi.func_t):
    """yield basic blocks contained in specified function"""
    # leverage idaapi.FC_NOEXT flag to ignore useless external blocks referenced by the function
    yield from idaapi.FlowChart(f, flags=(idaapi.FC_PREDS | idaapi.FC_NOEXT))


def first_pass_identify_impossible_jumps(
    start_ea, end_ea, display_detailed=False, memo=None
):
    """First pass static analysis to identify impossible conditional jumps in a function.
    It iterates over basic blocks, simulating flag state from deterministic instructions.
    When a conditional jump is encountered and its condition can be resolved using CF/OF,
    it prints whether the jump is always taken or never taken. Results are recorded in memo if provided.
    """

    print(
        f"Analyzing function at 0x{start_ea:X} to 0x{end_ea:X} to identify impossible jumps."
    )
    results = []
    # Iterate over basic blocks in the function

    flag_state = None
    head = idc.prev_head(start_ea)
    while True:
        head = idc.next_head(head, end_ea)
        if head == idc.BADADDR or head >= end_ea:
            break
        mnem = idc.print_insn_mnem(head)
        if not mnem:
            continue
        mnem_lower = mnem.lower()
        print(f"Processing instruction at 0x{head:X}: {mnem_lower}")
        # Update flag state with the current instruction
        flag_state = update_flag_state(flag_state, head)
        # Check if instruction is a conditional jump (but not an unconditional jmp)
        if not ConditionalJumps.is_jcc(mnem_lower):
            continue
        resolved = static_evaluate_jcc_condition(flag_state, mnem_lower)
        print(
            f"static evaluation of {mnem_lower} at 0x{head:X} with flag state {flag_state} is {resolved}"
        )
        if resolved is not None:
            if resolved:
                result_str = f"Conditional jump {mnem} at 0x{head:X} always TAKEN to 0x{idc.get_operand_value(head, 0):X}"
            else:
                next_addr = head + idc.get_item_size(head)
                result_str = f"Conditional jump {mnem} at 0x{head:X} never TAKEN (fallthrough always) to 0x{next_addr:X}"
            results.append(result_str)
            if display_detailed:
                print(result_str)
    print("\nSummary of statically resolved jumps:")
    for res in results:
        print(res)

    # Store results in memo if provided
    if memo is not None:
        memo["static_impossible_jumps"] = results


class ConditionalJumps(enum.IntFlag):
    """

    >>> print(ConditionalJumps.is_jcc("je"))
    True
    >>> print(ConditionalJumps.is_jcc("jexxx"))
    False
    >>> print(ConditionalJumps.is_jcc(decode_to_instr(idc.here())))
    True
    """

    ja = ida_allins.NN_ja
    jae = ida_allins.NN_jae
    jb = ida_allins.NN_jb
    jbe = ida_allins.NN_jbe
    jc = ida_allins.NN_jc
    jcxz = ida_allins.NN_jcxz
    jecxz = ida_allins.NN_jecxz
    jrcxz = ida_allins.NN_jrcxz
    je = ida_allins.NN_je
    jg = ida_allins.NN_jg
    jge = ida_allins.NN_jge
    jl = ida_allins.NN_jl
    jle = ida_allins.NN_jle
    jna = ida_allins.NN_jna
    jnae = ida_allins.NN_jnae
    jnb = ida_allins.NN_jnb
    jnbe = ida_allins.NN_jnbe
    jnc = ida_allins.NN_jnc
    jne = ida_allins.NN_jne
    jng = ida_allins.NN_jng
    jnge = ida_allins.NN_jnge
    jnl = ida_allins.NN_jnl
    jnle = ida_allins.NN_jnle
    jno = ida_allins.NN_jno
    jnp = ida_allins.NN_jnp
    jns = ida_allins.NN_jns
    jnz = ida_allins.NN_jnz
    jo = ida_allins.NN_jo
    jp = ida_allins.NN_jp
    jpe = ida_allins.NN_jpe
    jpo = ida_allins.NN_jpo
    js = ida_allins.NN_js
    jz = ida_allins.NN_jz

    @functools.singledispatch
    @staticmethod
    def is_jcc(instr: ida_ua.insn_t):
        """Is conditional branch?
        refer to intel.hpp/inline bool insn_jcc(const insn_t &insn)
        """
        return instr.itype in ConditionalJumps._value2member_map_

    @is_jcc.register(int)
    def _(ea: int):  # //NOSONAR
        """Is conditional branch?
        refer to intel.hpp/inline bool insn_jcc(const insn_t &insn)
        """
        return ea in ConditionalJumps._value2member_map_

    @is_jcc.register(str)
    def _(jump_str: str):
        """Is conditional branch based on mnemonic string.
        Returns True if the given string (case-insensitive) is a recognized conditional jump mnemonic.
        """
        is_allowed = jump_str.lower() in CONDITIONAL_JUMPS
        is_valid_enum = getattr(ConditionalJumps, jump_str.lower(), None) is not None
        # if not all([is_allowed, is_valid_enum]):
        #     print(
        #         f"{jump_str} is {is_allowed or 'NOT'} in the ALLOWED_MNEMONICS but {is_valid_enum or 'NOT'} a valid enum value"
        #     )
        return is_allowed or is_valid_enum


CONDITIONAL_JUMPS = [
    "ja",
    "jae",
    "jb",
    "jbe",
    "jc",
    "jcxz",
    "jecxz",
    "jrcxz",
    "je",
    "jg",
    "jge",
    "jl",
    "jle",
    "jna",
    "jnae",
    "jnb",
    "jnbe",
    "jnc",
    "jne",
    "jng",
    "jnge",
    "jnl",
    "jnle",
    "jno",
    "jnp",
    "jns",
    "jnz",
    "jo",
    "jp",
    "jpe",
    "jpo",
    "js",
    "jz",
]


@dataclass
class PatchOperation:
    """Class to store patch operations that will be applied later."""

    address: int
    byte_value: int

    def apply(self):
        """Apply the patch operation."""
        ida_bytes.patch_byte(self.address, self.byte_value)
        logger.debug(
            f"Applied patch at 0x{self.address:x} with value 0x{self.byte_value:x}"
        )

    def __str__(self):
        """String representation with hex formatting."""
        return f"PatchOperation(address=0x{self.address:X} , byte_value={self.byte_value:X}h)"


def is_in_range(addr, base_address, buffer_end_ea):
    """
    Helper to see if 'addr' is located within our buffer range.
    """
    return base_address <= addr < buffer_end_ea


def deflow(functions=None, text_seg_buffer=False):
    """
    // Buffer is a copy of the .text section.
    // 'functions' is an iterable of function entry points (start addresses) in the .text section.
    // This uses IDA's Python API to retrieve and patch bytes in the .text section.
    """
    if logger.isEnabledFor(logging.DEBUG):
        logger.debug(
            "Starting deflow with functions: %s, text_seg_buffer: %s",
            ", ".join([format_addr(f) for f in functions]),
            text_seg_buffer,
        )

    # Get the start of the .text segment and its size in IDA.
    text_seg = ida_segment.get_segm_by_name(".text")
    if not text_seg:
        print("[-] Could not find .text segment.")
        return

    if not functions:
        functions = idautils.Functions(text_seg.start_ea, text_seg.end_ea)

    logger.debug(
        "Processing %d functions in text segment range: base_address=0x%x, end_address=0x%x, size=%d",
        len(functions),
        text_seg.start_ea,
        text_seg.end_ea,
        text_seg.end_ea - text_seg.start_ea,
    )

    for func_addr in ida_tguidm(functions):
        logger.debug("Processing function at address: 0x%x", func_addr)
        # if buffer is None, we use the function's entire range as buffer
        # unless we asked to use the entire .text segment as buffer.

        # Reset patch operations for this function
        patch_operations = []

        func = ida_funcs.get_func(func_addr)
        logger.debug(
            "Function 0x%x: start_ea=0x%x, end_ea=0x%x, size=%d",
            func_addr,
            func.start_ea,
            func.end_ea,
            func.end_ea - func.start_ea,
        )
        chunks = deflow_chunk(
            text_seg.start_ea,
            text_seg.end_ea,
            func.start_ea,
            func.end_ea,
            patch_operations,
        )
        logger.debug(
            "Initial chunks from deflow_chunk for function 0x%x: %s",
            func_addr,
            ", ".join([format_addr(c) for c in chunks]),
        )
        while True:
            if not chunks:
                break
            new_chunks = []
            for c in monitored_iter(chunks):
                logger.debug("Processing chunk at 0x%x", c)
                new_chunks.extend(
                    deflow_chunk(
                        text_seg.start_ea,
                        text_seg.end_ea,
                        c,
                        func.end_ea,
                        patch_operations,
                    )
                )
            if logger.isEnabledFor(logging.DEBUG):
                logger.debug(
                    "New chunks after iteration: %s",
                    ", ".join([format_addr(c) for c in new_chunks]),
                )
            chunks = new_chunks

        # Now apply all collected patches for this function
        logger.debug(
            f"Applying {len(patch_operations)} patch operations for function 0x{func_addr:x}"
        )
        for operation in patch_operations:
            operation.apply()
            # ea = operation.address
            # if not is_jump_instruction(ea):
            #     continue
            # target, jmp_size = get_jump_target(ea)
            # if target is None or target <= ea or target > ea + MAX_STUB_SIZE:
            #     continue
            # if target - ea < MIN_STUB_SIZE:
            #     continue
            # if not is_junk_region(ea + jmp_size, target, func.end_ea):
            #     continue
            # if ends_with_big_instruction(ea, target) or is_jump_instruction(target):
            #     neutralize_stub(ea, target)


def disassemble(ea):
    """Get the disassembly text associated witn an `ea`."""
    return idc.generate_disasm_line(ea, idc.GENDSM_FORCE_CODE)


def handle_branch_instruction(
    insn,
    location,
    last_branch,
    last_branch_size,
    last_target,
    buffer_start_ea,
    is_jmp,
    target,
    is_negative,
    new_chunks,
    patch_operations,
):
    """
    Handle branch instruction analysis for opaque predicate detection and removal.

    Args:
        insn: Current instruction being analyzed
        location: Address of the current instruction
        last_branch: Address of the last branch instruction
        last_branch_size: Size of the last branch instruction
        last_target: Target address of the last branch
        buffer_start_ea: Start address of the buffer being analyzed
        is_jmp: Whether the current instruction is a jump
        target: Target address of the current jump instruction
        is_negative: Whether the jump is negative
        new_chunks: List of new code chunks to analyze

    Returns:
        Updated list of new chunks if branch handling is complete, None otherwise
    """
    # Steps (bytes) left to reach lastTarget from current address
    steps_left = last_target - location  # Only valid if we have a last_target

    # Setup a new target if current instruction is a conditional jump
    # while there is no last_target
    if last_target == 0 and is_jmp:
        last_branch = location
        last_branch_size = insn.size
        last_target = target
        logger.debug(
            "Setting branch info: last_branch=0x%x, last_branch_size=%d, last_target=0x%x",
            last_branch,
            last_branch_size,
            last_target,
        )
        return None, last_branch, last_branch_size, last_target
    elif steps_left == 0 and last_target != 0:
        logger.debug(
            "Exact collision at 0x%x; adding 0x%x and 0x%x",
            location,
            last_branch + last_branch_size,
            last_target,
        )
        new_chunks.append(last_branch + last_branch_size)
        new_chunks.append(last_target)
        return new_chunks, last_branch, last_branch_size, last_target
    elif steps_left < 0 and last_target != 0:
        # stepsLeft != 0 => collision within the instruction => obfuscated
        # int count = lastTarget = lastBranch;
        # (The original code is a bit ambiguous, but the comment suggests
        #  we measure how many bytes we are "into" the next instruction)
        count = last_target - last_branch
        logger.debug(
            "Obfuscated branch detected at 0x%x; count: %d", last_branch, count
        )
        if count > 0:
            # making sure we are a positive jump
            buffer_offset = last_branch - buffer_start_ea  # index in local buffer

            # NOP slide everything except our own instruction
            # for (int i = 0; i < count - lastBranchSize; i++)
            for i in range(count - last_branch_size):
                patch_addr = buffer_start_ea + buffer_offset + last_branch_size + i
                patch_byte = 0x90 if is_negative else 0xCC
                # ida_bytes.patch_byte(patch_addr, patch_byte)
                patch_operations.append(PatchOperation(patch_addr, patch_byte))
                logger.debug("Patching byte at 0x%x with 0x%x", patch_addr, patch_byte)

            if not is_negative:
                # Force unconditional jump
                # ida_bytes.patch_byte(buffer_start_ea + buffer_offset, 0xEB)
                patch_operations.append(
                    PatchOperation(buffer_start_ea + buffer_offset, 0xEB)
                )
                logger.debug(
                    "Forced unconditional jump at 0x%x",
                    buffer_start_ea + buffer_offset,
                )

            # add next instruction for analysis and exit current analysis
            new_chunks.append(last_target)
            logger.debug("Added new chunk target 0x%x", last_target)
            return new_chunks, last_branch, last_branch_size, last_target
        else:
            # we are a negative jump, set 63rd bit to indicate negative jump
            last_target = -last_target
            logger.debug(
                "Negative jump encountered. Adjusted last_target: 0x%x", last_target
            )
            # add target to analyzer and exit current analysis
            new_chunks.append(last_target)
            return new_chunks, last_branch, last_branch_size, last_target

    return None, last_branch, last_branch_size, last_target


def calc_target_jump(insn: capstone.CsInsn):
    """
    Helper to extract jump or call target from an instruction.
    In Capstone, you can often inspect insn.operands[0].imm for near branches.
    """
    operand = idc.get_operand_value(insn.address, 0)
    # if not insn.detail or len(insn.operands) == 0:
    #     logger.debug(
    #         "No detailed operand info for instruction at %s", format_addr(insn.address)
    #     )
    #     # return None
    op = insn.operands[0]
    if op.type == capstone.x86.X86_OP_IMM:
        target = op.imm
        logger.debug(
            "@ insn.address: %s with jump target: %s",
            format_addr(insn.address),
            format_addr(target),
        )
        # return target
    else:
        logger.debug("Operand not immediate at %s", format_addr(insn.address))
        # return None
    return operand


# Add these helper functions to detect anti-disassembly patterns


def deflow_chunk(
    buffer_start_ea, buffer_end_ea, address, ending_address, patch_operations
):
    logger.debug("Starting deflow_chunk analysis for address: 0x%x", address)
    new_chunks = []

    is_negative = address < 0
    address = abs(address)

    # Check if we have already discovered this address
    if address in _already_discovered:
        logger.debug("Address 0x%x already discovered, skipping.", address)
        return new_chunks

    _already_discovered.add(address)

    # We'll keep track of potential obfuscated branches
    last_branch = 0  # Indicates our last conditional jump address
    last_branch_size = 0  # Size of the last conditional jump instruction
    last_target = 0  # Target location of the last conditional jump

    # NOTE: base = baseAddress + .text offset.
    # We'll create a Capstone disassembler for x86_64.
    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    md.detail = True

    # Calculate the offset in 'buffer' corresponding to 'address'.
    # If address < base_address, handle accordingly (in_range checks, etc.).
    if not is_in_range(address, buffer_start_ea, buffer_end_ea):
        logger.debug(
            "Address %s out of range [%s - %s]",
            format_addr(address),
            format_addr(buffer_start_ea),
            format_addr(buffer_end_ea),
        )
        return new_chunks

    # Disassemble from 'address' until we run out of bytes
    buffer_size = ending_address - address
    if buffer_size < 0:
        buffer_size = 0x8000  # just take 512kb from the buffer size..

    buffer = ida_bytes.get_bytes(address, buffer_size)
    insn = None
    for insn in md.disasm(buffer, address):
        logger.debug(
            "Disassembled instruction at 0x%x: %s %s",
            insn.address,
            insn.mnemonic,
            insn.op_str,
        )
        insn = typing.cast(capstone.CsInsn, insn)

        # We'll track potential jump targets
        target = 0
        is_jmp = True

        #
        # The original pseudocode uses a switch on insn.Mnemonic:
        # switch(insn.Mnemonic)
        #
        # We'll approximate by checking groups of mnemonics:
        #

        # 1) Check for invalid / return instructions
        #    // Stop analyzing when we encounter an invalid or return instruction
        #    // while we have no lastTarget.
        if (
            insn.id == 0
            or insn.mnemonic in ["ret", "retn"]
            or insn.mnemonic.startswith("ret")
            or insn.mnemonic == "int"
        ):
            logger.debug(
                "Encountered return or invalid instruction at 0x%x", insn.address
            )
            if last_target == 0:
                return new_chunks  # Only accept when no lastTarget
            # If there is a last_target, continue analysis.

        # 2) Check for conditional jump instructions
        elif insn.mnemonic in CONDITIONAL_JUMPS:
            # if(lastTarget == 0)
            if last_target == 0:
                target = calc_target_jump(insn)
                logger.debug(
                    "Conditional jump at 0x%x with target 0x%x", insn.address, target
                )

                # Check if in range
                if not is_in_range(target, buffer_start_ea, buffer_end_ea):
                    logger.debug("Target 0x%x out of range", target)
                    is_jmp = False
                else:
                    # Check if instruction is bigger than 2,
                    # if so it won't be obfuscated but we do want to analyze the target location
                    if insn.size > 2:
                        logger.debug(
                            "Instruction size > 2 at 0x%x; adding target 0x%x and stopping jump analysis",
                            insn.address,
                            target,
                        )
                        is_jmp = False
                        new_chunks.append(target)
            else:
                # Do not accept any conditional jumps if we already have a last_target
                # (might be looking at junk code)
                logger.debug(
                    "Skipping conditional jump at 0x%x due to existing last_target 0x%x",
                    insn.address,
                    last_target,
                )
                is_jmp = False
        # 3) Check for unconditional jumps or calls
        elif insn.mnemonic in ["jmp", "call"] and last_target == 0:
            target = calc_target_jump(insn)
            real_head = idc.get_item_head(target)
            logger.debug(
                "Unconditional %s at 0x%x with target 0x%x",
                insn.mnemonic,
                insn.address,
                target,
            )
            if not is_in_range(target, buffer_start_ea, buffer_end_ea):
                logger.debug("New address 0x%x out of range", target)
                is_jmp = False
            else:
                if insn.mnemonic == "call":
                    # address + insn.size => next instruction's address
                    next_insn_addr = idc.next_addr(insn.address)
                    if next_insn_addr != (address + insn.size):
                        logger.warning(
                            "Call instruction: next instruction address 0x%x is not the expected 0x%x. Reverting",
                            next_insn_addr,
                            address + insn.size,
                        )
                        next_insn_addr = address + insn.size
                    logger.debug(
                        "Call instruction: adding next instruction address 0x%x",
                        next_insn_addr,
                    )
                    new_chunks.append(next_insn_addr)
                # Add instruction target for further analysis
                new_chunks.append(target)
                return new_chunks
            # elif target == real_head:
            #     # If it's a CALL, add the next instruction
            #     # (since CALL returns eventually)
            #     if insn.mnemonic == "call":
            #         # address + insn.size => next instruction's address
            #         next_insn_addr = address + insn.size
            #         logger.debug(
            #             "Call instruction: adding next instruction address 0x%x",
            #             next_insn_addr,
            #         )
            #         new_chunks.append(next_insn_addr)
            #     # Add instruction target for further analysis
            #     new_chunks.append(target)
            #     return new_chunks
            # else:
            #     logger.debug(
            #         "Unconditional %s at 0x%x with target 0x%x is obfuscated",
            #         insn.mnemonic,
            #         insn.address,
            #         target,
            #     )
            #     new_chunks.append(target)
        else:
            # it's not a jump, so we can't handle it
            is_jmp = False

        # Call the extracted function to handle branch instructions
        result, last_branch, last_branch_size, last_target = handle_branch_instruction(
            insn,
            insn.address,  # In Capstone, insn.address is the runtime address
            last_branch,
            last_branch_size,
            last_target,
            buffer_start_ea,
            is_jmp,
            target,
            is_negative,
            new_chunks,
            patch_operations,
        )

        if result is not None:
            return result

    else:
        if insn:
            logger.debug(
                "last instruction disassembled: %s @ 0x%x and last_target: 0x%x",
                insn.mnemonic,
                insn.address,
                last_target,
            )
            target_head = idc.prev_head(last_target)
            if last_target != 0 and target_head != last_target:
                # create an artifical collision by using the previous head of the last target

                A = idc.get_item_size(target_head)
                B = last_target - target_head
                location = target_head + B + 1  # go past last_target by just 1 byte
                logger.debug(
                    "idc.prev_head(0x%x) = 0x%x, location: 0x%x, last_branch: 0x%x, last_branch_size: %d, last_target: 0x%x, is_jmp: %s, target: 0x%x, is_negative: %s",
                    last_target,
                    target_head,
                    location,
                    last_branch,
                    last_branch_size,
                    last_target,
                    is_jmp,
                    target,
                    is_negative,
                )
                result, last_branch, last_branch_size, last_target = (
                    handle_branch_instruction(
                        insn,
                        location,
                        last_branch,
                        last_branch_size,
                        last_target,
                        buffer_start_ea,
                        is_jmp,
                        target,
                        is_negative,
                        new_chunks,
                        patch_operations,
                    )
                )

    return new_chunks


class AegisUndoer:
    def __init__(self):
        self.is_x64 = ida_ida.inf_is_64bit()

        # Create Capstone disassembler
        self.md = capstone.Cs(
            capstone.CS_ARCH_X86,
            capstone.CS_MODE_64 if self.is_x64 else capstone.CS_MODE_32,
        )
        self.md.detail = True

        # Known block size from the provided information
        self.BLOCK_SIZE = 54

        # Jump opcodes for detection
        self.JUMP_OPCODES = list(range(0x70, 0x80)) + [0xEB, 0xE9]

        # Statistics
        self.blocks_found = 0
        self.blocks_patched = 0

        # Set to track analyzed functions to avoid duplicates
        self.analyzed_functions = set()

    def evaluate_jump(self, ea):
        """Analyze a jump instruction and return its destination and size"""
        inst_byte = ida_bytes.get_byte(ea)

        # Short conditional jumps (0x70-0x7F) or short JMP (0xEB)
        if (inst_byte >= 0x70 and inst_byte <= 0x7F) or inst_byte == 0xEB:
            offset = ida_bytes.get_byte(ea + 1)
            # Handle signed byte offset
            if offset > 127:
                offset = offset - 256
            jmp_size = 2
            jmp_dest = ea + jmp_size + offset
            return (jmp_dest, jmp_size, True)

        # Near JMP (0xE9)
        elif inst_byte == 0xE9:
            offset = ida_bytes.get_dword(ea + 1)
            # Handle signed dword offset
            if offset > 0x7FFFFFFF:
                offset = offset - 0x100000000
            jmp_size = 5
            jmp_dest = ea + jmp_size + offset
            return (jmp_dest, jmp_size, True)

        # Near conditional jumps (0x0F 0x80-0x8F)
        elif inst_byte == 0x0F:
            second_byte = ida_bytes.get_byte(ea + 1)
            if second_byte >= 0x80 and second_byte <= 0x8F:
                offset = ida_bytes.get_dword(ea + 2)
                # Handle signed dword offset
                if offset > 0x7FFFFFFF:
                    offset = offset - 0x100000000
                jmp_size = 6
                jmp_dest = ea + jmp_size + offset
                return (jmp_dest, jmp_size, True)

        # Not a jump instruction
        return (0, 0, False)

    def scan_for_circular_jumps(self, start_ea=None, end_ea=None):
        """
        Scan for 54-byte blocks containing circular jumps

        Args:
            start_ea: Optional starting address to scan (beginning of function)
            end_ea: Optional ending address to scan (end of function)
        """
        if start_ea is not None and end_ea is not None:
            print(
                f"[*] Scanning for 54-byte anti-disassembly blocks in function {format_addr(start_ea)}..."
            )
            scan_ranges = [(start_ea, end_ea)]
        else:
            print(
                "[*] Scanning for 54-byte anti-disassembly blocks across all executable segments..."
            )
            # Search each executable segment
            scan_ranges = []
            for seg_idx in range(idaapi.get_segm_qty()):
                seg = idaapi.getnseg(seg_idx)
                if not seg or not (seg.perm & idaapi.SEGPERM_EXEC):
                    continue
                scan_ranges.append((seg.start_ea, seg.end_ea))

        blocks_found = []

        # Scan each range
        for range_start, range_end in scan_ranges:
            # Scan the range
            ea = range_start
            while ea < range_end - self.BLOCK_SIZE:
                # Check if this address contains a jump instruction
                jmp_dest, jmp_size, is_jump = self.evaluate_jump(ea)

                if is_jump:
                    # Check if jump target is within the expected 54-byte block
                    if ea <= jmp_dest < ea + self.BLOCK_SIZE:
                        # Verify this is likely an anti-disassembly block by checking:
                        # 1. Multiple jumps in the block
                        # 2. At least one backward jump
                        jumps_found = 0
                        has_backward_jump = False

                        for offset in range(self.BLOCK_SIZE):
                            check_ea = ea + offset
                            check_dest, _, check_is_jump = self.evaluate_jump(check_ea)

                            if check_is_jump:
                                jumps_found += 1
                                if check_dest < check_ea:
                                    has_backward_jump = True

                        # If we have multiple jumps and at least one backward jump, likely anti-disassembly
                        if jumps_found >= 2 and has_backward_jump:
                            blocks_found.append(ea)
                            print(
                                f"[+] Found potential anti-disassembly block at {format_addr(ea)}"
                            )

                ea += 1

                # Show progress periodically for larger scans
                if ea % 100000 == 0 and start_ea is None:
                    print(f"[*] Scanning: {format_addr(ea)}")

        # Update total blocks found count
        self.blocks_found += len(blocks_found)
        if start_ea is not None:
            print(
                f"[*] Found {len(blocks_found)} potential anti-disassembly blocks in function {format_addr(start_ea)}"
            )
        else:
            print(f"[*] Found {self.blocks_found} potential anti-disassembly blocks")

        return blocks_found

    def scan_for_collision_jumps(self, start_ea=None, end_ea=None):
        """
        Scan for 54-byte blocks containing opaque predicates (collision jumps)

        Args:
            start_ea: Optional starting address to scan (beginning of function)
            end_ea: Optional ending address to scan (end of function)
        """
        if start_ea is not None and end_ea is not None:
            print(
                f"[*] Scanning for opaque predicates in function {format_addr(start_ea)}..."
            )
            scan_ranges = [(start_ea, end_ea)]
        else:
            print(
                "[*] Scanning for opaque predicates in 54-byte blocks across all executable segments..."
            )
            # Search each executable segment
            scan_ranges = []
            for seg_idx in range(idaapi.get_segm_qty()):
                seg = idaapi.getnseg(seg_idx)
                if not seg or not (seg.perm & idaapi.SEGPERM_EXEC):
                    continue
                scan_ranges.append((seg.start_ea, seg.end_ea))

        blocks_found = []

        # Scan each range
        for range_start, range_end in scan_ranges:
            # Scan the range
            ea = range_start
            while ea < range_end - self.BLOCK_SIZE:
                # Verify this is a 54-byte block by checking for collision jumps
                collision_found = False

                for offset in range(
                    self.BLOCK_SIZE - 2
                ):  # -2 because jump needs at least 2 bytes
                    check_ea = ea + offset
                    jmp_dest, _, is_jump = self.evaluate_jump(check_ea)

                    if is_jump and ea <= jmp_dest < ea + self.BLOCK_SIZE:
                        # Check if jump destination is not at an instruction boundary
                        dest_head = idc.get_item_head(jmp_dest)
                        if dest_head != jmp_dest:
                            collision_found = True
                            break

                if collision_found:
                    blocks_found.append(ea)
                    print(f"[+] Found potential opaque predicate at {format_addr(ea)}")

                ea += 1

                # Show progress periodically for larger scans
                if ea % 100000 == 0 and start_ea is None:
                    print(f"[*] Scanning: {format_addr(ea)}")

        # Add to total blocks found
        blocks_count = len(blocks_found)
        self.blocks_found += blocks_count

        if start_ea is not None:
            print(
                f"[*] Found {blocks_count} blocks with opaque predicates in function {format_addr(start_ea)}"
            )
        else:
            print(f"[*] Found {blocks_count} blocks with opaque predicates")

        return blocks_found

    def patch_block(self, block_ea):
        """Patch a 54-byte anti-disassembly block by NOPing it out"""
        print(f"[*] Patching anti-disassembly block at {format_addr(block_ea)}")

        # NOP out the entire 54-byte block
        for offset in range(self.BLOCK_SIZE):
            ida_bytes.patch_byte(block_ea + offset, 0x90)

        # Re-analyze the patched area
        ida_bytes.del_items(block_ea, 0, self.BLOCK_SIZE)
        ida_bytes.create_insn(block_ea)

        # Mark the patched area with a comment
        idc.set_cmt(block_ea, f"[PATCHED] Aegis Anti-Disassembly Block (54 bytes)", 0)

        self.blocks_patched += 1
        print(
            f"[+] Successfully patched anti-disassembly block at {format_addr(block_ea)}"
        )

    def analyze_function(self, func_ea):
        """Analyze a specific function for anti-disassembly blocks"""
        if func_ea in self.analyzed_functions:
            print(f"[*] Function {format_addr(func_ea)} already analyzed, skipping")
            return []

        # Get function boundaries
        func = ida_funcs.get_func(func_ea)
        if not func:
            print(f"[!] No function at {format_addr(func_ea)}")
            return []

        print(
            f"[*] Analyzing function {format_addr(func_ea)} (size: {func.end_ea - func.start_ea} bytes)"
        )
        self.analyzed_functions.add(func_ea)

        # Find anti-disassembly blocks in this function
        circular_blocks = self.scan_for_circular_jumps(func.start_ea, func.end_ea)
        collision_blocks = self.scan_for_collision_jumps(func.start_ea, func.end_ea)

        # Combine and deduplicate blocks
        all_blocks = sorted(set(circular_blocks + collision_blocks))

        if not all_blocks:
            print(
                f"[*] No anti-disassembly blocks found in function {format_addr(func_ea)}"
            )
            return []

        print(
            f"[*] Found {len(all_blocks)} anti-disassembly blocks in function {format_addr(func_ea)}"
        )

        # Patch each block
        for block_ea in all_blocks:
            try:
                self.patch_block(block_ea)
            except Exception as e:
                print(f"[!] Error patching at {format_addr(block_ea)}: {str(e)}")

        # Refresh after patching
        ida_kernwin.refresh_idaview_anyway()

        return all_blocks

    def run(self, func_ea=None):
        """
        Main function to find and patch all 54-byte anti-disassembly blocks

        Args:
            func_ea: Optional function address to focus analysis on
        """
        print("=" * 60)
        print("Aegis 54-Byte Anti-Disassembly Block Undoer")
        print("=" * 60)
        print(f"Architecture: {'x64' if self.is_x64 else 'x86'}")

        if func_ea is not None:
            # Analyze a specific function
            self.analyze_function(func_ea)
        else:
            # Find all anti-disassembly blocks across the entire binary
            circular_blocks = self.scan_for_circular_jumps()
            collision_blocks = self.scan_for_collision_jumps()

            # Combine and deduplicate blocks
            all_blocks = sorted(set(circular_blocks + collision_blocks))

            if not all_blocks:
                print("[!] No anti-disassembly blocks found")
                return

            print("\n[*] Starting to patch anti-disassembly blocks...")

            # Patch each block
            for block_ea in all_blocks:
                try:
                    self.patch_block(block_ea)
                except Exception as e:
                    print(f"[!] Error patching at {format_addr(block_ea)}: {str(e)}")

        print("\n" + "=" * 60)
        print(
            f"[*] Patching complete: {self.blocks_patched}/{self.blocks_found} anti-disassembly blocks removed"
        )
        print("=" * 60)

        # Refresh the view
        ida_kernwin.refresh_idaview_anyway()


@dataclasses.dataclass
class DeflowopaquepredicatesActionHandler(ida_helpers.BaseActionHandler):
    """Deflow Opaque Predicates"""

    action_name: str = "mutilz:deflow_opaque_predicates"
    action_label: str = "Deflow Opaque Predicates"
    icon: int = 171

    def activate(self, ctx):
        ea = idaapi.get_screen_ea()
        func = ida_funcs.get_func(ea)
        if func:
            start_ea = func.start_ea
            end_ea = func.end_ea
        else:
            is_selected, start_ea, end_ea = idaapi.read_range_selection(
                idaapi.get_current_viewer()
            )
            if is_selected and start_ea != idaapi.BADADDR and end_ea != idaapi.BADADDR:
                # reset ea to start_ea since we selected a range specifically to the
                # start and end of the range
                ea = start_ea
            else:
                start_ea = ea
                print("No range selected.")
                end_ea = ida_kernwin.ask_addr(
                    start_ea, "Enter end address for selection:"
                )
                if end_ea is None:
                    print("Selection cancelled.")
                    return
                if end_ea <= start_ea:
                    print("Error: End address must be greater than start address.")
                    return
            print(f"Selection start: 0x{start_ea:X}, end: 0x{end_ea:X} (user-defined)")

        try:
            memo = {}
            # first_pass_identify_impossible_jumps(
            #     start_ea, end_ea, display_detailed=True, memo=memo
            # )
            deflow(functions=[start_ea], text_seg_buffer=True)
            # AegisUndoer().run(start_ea)
        finally:
            # clear the already discovered addresses
            _already_discovered.clear()
            idc.jumpto(ea)

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class DeflowopaquepredicatesAction(
    actions.action_t, metaclass=ida_helpers.HookedActionMeta
):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        DeflowopaquepredicatesActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return DeflowopaquepredicatesAction()
