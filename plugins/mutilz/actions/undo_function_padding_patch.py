# generated by mutilz cli at 2025-04-08 22:18:42
import dataclasses
import functools
import logging
import re
import time
import typing
from dataclasses import dataclass
from enum import Enum

import ida_bytes
import ida_funcs
import ida_kernwin
import ida_segment
import ida_ua
import idaapi
import idautils
import idc
import mutilz.actions as actions
import mutilz.helpers.ida as ida_helpers
from mutilz.helpers.idare import MemHelper, PatternCategory, RegexPatternMetadata
from mutilz.logconf import configure_logging

logger = logging.getLogger("mutilz.actions.undo_function_padding_patch")
configure_logging(log=logger)


# --- Reusable Padding Finder ---
class FunctionPaddingFinder:
    @staticmethod
    def is_cc_byte(ea):
        return ida_bytes.get_byte(ea) == 0xCC

    @classmethod
    def find_cc_sequences(cls, start_ea, end_ea, min_length=1):
        result = []
        current_start = None
        ea = start_ea
        while ea < end_ea:
            if cls.is_cc_byte(ea):
                if current_start is None:
                    current_start = ea
            else:
                if current_start is not None:
                    seq_len = ea - current_start
                    if seq_len >= min_length:
                        result.append((current_start, ea - 1, seq_len))
                    current_start = None  # Reset sequence tracking
            # Ensure we handle potential invalid addresses during iteration
            try:
                # Advance byte by byte for simple CC check
                ea += 1
            except:
                break  # Stop if issues occur

        # Handle sequence ending exactly at end_ea
        if current_start is not None:
            seq_len = end_ea - current_start
            if seq_len >= min_length:
                # The end address in the tuple is inclusive
                result.append((current_start, end_ea - 1, seq_len))
        return result

    @staticmethod
    def is_special_sequence(ea):
        bytes_at_ea = ida_bytes.get_bytes(ea, 5)
        if not bytes_at_ea:
            return False
        sequences = [
            b"\x66\x90",
            b"\x0f\x1f\x00",
            b"\x0f\x1f\x40\x00",
            b"\x0f\x1f\x44\x00\x00",
            b"\x66\x0f\x1f\x44\x00\x00",
            b"\x0f\x1f\x80\x00\x00\x00\x00",
            b"\x0f\x1f\x84\x00\x00\x00\x00\x00",
            b"\x66\x0f\x1f\x84\x00\x00\x00\x00\x00",
            b"\x66\x66\x0f\x1f\x84\x00\x00\x00\x00\x00",
            b"\x66\x66\x66\x0f\x1f\x84\x00\x00\x00\x00\x00",
        ]
        short_sequences = [s for s in sequences if len(s) <= len(bytes_at_ea)]
        return any(bytes_at_ea.startswith(seq) for seq in short_sequences)


# Check if an address is in a non-executable section
def is_non_executable(ea):
    seg = idaapi.getseg(ea)
    if not seg:
        return False
    return (seg.perm & idaapi.SEGPERM_EXEC) == 0


# --- Added helper function ---
def _determine_alignment_exponent(address: int) -> int:
    """
    Determines the alignment exponent (log2) based on the address.
    Checks for 16, 8, 4, 2 byte alignment. Returns 0 if none match.
    """
    if (address % 16) == 0:
        return 4  # log2(16)
    elif (address % 8) == 0:
        return 3  # log2(8)
    elif (address % 4) == 0:
        return 2  # log2(4)
    elif (address % 2) == 0:
        return 1  # log2(2)
    else:
        return 0  # No specific alignment (or 1-byte aligned)


# Main function with dry-run option
def undo_function_padding_patching(start_ea, end_ea, dry_run=True):
    logger.info(
        "Starting function padding unpatching (Dry Run: %s)...",
        "Enabled" if dry_run else "Disabled",
    )

    # Get file boundaries
    start_ea = start_ea or idc.get_inf_attr(idc.INF_MIN_EA)
    end_ea = end_ea or idc.get_inf_attr(idc.INF_MAX_EA)
    logger.info(f"File EA range: {hex(start_ea)} - {hex(end_ea)}")
    # Initialize MemHelper to retrieve memory bytes
    mem_helper = MemHelper(start_ea, end_ea)

    # Define regex pattern to find 0xC3 (RET instruction)
    pattern_metadata = RegexPatternMetadata(
        category=PatternCategory.FUNCTION_PADDING,
        pattern=b"\xc3",
        description="Find RET instructions",
    )
    pattern = pattern_metadata.compile()

    patched_count = 0
    # Find all occurrences of 0xC3 in the memory
    for match in pattern.finditer(mem_helper.mem_results):
        # Convert match offset to EA
        offset = match.start()
        ea_c3 = mem_helper.start + offset
        p_patch_bytes = ea_c3 + 1  # Start of the sequence to patch

        # Find the end of the sequence
        p_end = p_patch_bytes
        while p_end < mem_helper.end:
            # Calculate RVA relative to image base
            rva = p_end - idaapi.get_imagebase()

            # Check if end conditions are NOT met
            is_aligned = (rva & 0xF) == 0
            is_special = FunctionPaddingFinder.is_special_sequence(p_end)

            if not (is_aligned or is_special):
                p_end += 1
                continue  # Continue searching if neither condition is met

            # --- End conditions met, process the sequence ---
            sequence_length = p_end - p_patch_bytes
            if sequence_length >= 5:
                # Valid sequence found
                logger.info(f"Candidate at EA {hex(p_patch_bytes)} to {hex(p_end - 1)}")
                if dry_run:
                    logger.info(
                        f"    [Dry Run] Would patch {sequence_length} bytes to 0xCC and align"
                    )
                else:
                    # Patch the sequence to 0xCC
                    logger.info(f"    Patching {sequence_length} bytes to 0xCC...")
                    ida_bytes.patch_bytes(p_patch_bytes, b"\xcc" * sequence_length)
                    logger.info(f"    Patched {sequence_length} bytes to 0xCC.")

                    # --- Add alignment logic ---
                    next_ea = (
                        p_end  # Address immediately following the patched sequence
                    )
                    align_exponent = _determine_alignment_exponent(next_ea)
                    align_val = 1 << align_exponent

                    logger.info(
                        f"    Attempting to undefine and align patched range to {align_val} bytes (exponent {align_exponent})..."
                    )

                    # Undefine padding first
                    if not ida_bytes.del_items(
                        p_patch_bytes, ida_bytes.DELIT_EXPAND, sequence_length
                    ):
                        logger.warning(
                            f"    Could not fully undefine padding range at 0x{p_patch_bytes:X} before alignment."
                        )

                    # Create the alignment directive
                    if align_exponent > 0:
                        if ida_bytes.create_align(
                            p_patch_bytes, sequence_length, align_exponent
                        ):
                            logger.info(
                                f"    Successfully created align {align_val} directive for patched range."
                            )
                        else:
                            logger.warning(
                                f"    Failed to create align directive for patched range at 0x{p_patch_bytes:X}."
                            )
                    else:
                        logger.info(
                            f"    No specific alignment needed (exponent is 0, next_ea=0x{next_ea:X})."
                        )
                    # --- End alignment logic ---

                patched_count += 1
                return
            # Break the inner while loop since we found the end or the sequence wasn't valid
            break
            # The p_end += 1 is now handled by the continue statement above

    logger.info(f"Unpatching complete. Found {patched_count} sequences.")


def execute_action(start_ea: int, end_ea: int, dry_run: bool = True):
    # Optional: Configure logger here if you want specific settings for standalone runs
    # logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Using func.start_ea instead of curr_ea for the start range seems more appropriate
    # Also, end + 0x100 might go too far, using func.end_ea is safer unless padding is known to extend significantly
    undo_function_padding_patching(start_ea, end_ea + 0x100, dry_run)


@dataclasses.dataclass
class UndoFunctionPaddingPatchActionHandler(ida_helpers.BaseActionHandler):
    """Undo Function Padding Patch"""

    action_name: str = "mutilz:undo_function_padding_patch"
    action_label: str = "Undo Function Padding Patch"
    icon: int = 171

    def get_selected_addresses(self, ctx):
        is_selected, start_ea, end_ea = idaapi.read_range_selection(
            idaapi.get_current_viewer()
        )
        if is_selected:
            return start_ea, end_ea

        # maybe it's the same line?
        p0, p1 = ida_kernwin.twinpos_t(), ida_kernwin.twinpos_t()
        ida_kernwin.read_selection(ctx.widget, p0, p1)
        p0.place(ctx.widget)
        p1.place(ctx.widget)
        if p0.at and p1.at:
            start_ea = p0.at.toea()
            end_ea = p1.at.toea()
            if start_ea == end_ea:
                start_ea = idc.get_item_head(start_ea)
                end_ea = idc.get_item_end(start_ea)
                return start_ea, end_ea

        # if we are here, we haven't selected anything, so we use the current address
        start_ea = idaapi.get_screen_ea()
        try:
            end_ea = ida_kernwin.ask_addr(start_ea, "Enter end address for selection:")
        finally:
            # restore the cursor to the original address
            idc.jumpto(start_ea)

        if end_ea and end_ea <= start_ea:
            print(
                f"Error: End address 0x{end_ea:X} must be greater than start address 0x{start_ea:X}."
            )
            end_ea = None

        if end_ea is None:
            # if we canceled the dialog, let's assume the user wants
            # to select just the line they're on
            end_ea = idc.get_item_end(start_ea)
            print(f"No end address selected, using line end: 0x{end_ea:X}")

        return start_ea, end_ea

    def activate(self, ctx):
        curr_ea = idaapi.get_screen_ea()
        start_ea, end_ea = self.get_selected_addresses(ctx)
        try:
            func = ida_funcs.get_func(start_ea)
            if not func:
                # Consider using logger.error or raising an exception
                logger.error(
                    "No function found at current cursor position."
                )  # Kept print for initial error before logging might be set up
                return
            end = func.end_ea
            execute_action(start_ea, end, dry_run=False)
        finally:
            idc.jumpto(curr_ea)

    def update(self, ctx):
        match ctx.widget_type:
            case idaapi.BWN_DISASM:
                return idaapi.AST_ENABLE_FOR_WIDGET
            case _:
                return idaapi.AST_DISABLE_FOR_WIDGET


class UndoFunctionPaddingPatchAction(
    actions.action_t, metaclass=ida_helpers.HookedActionMeta
):
    uihook_class = functools.partial(
        ida_helpers.PopUpHook,
        UndoFunctionPaddingPatchActionHandler,
        ida_helpers.is_disassembly_widget,
    )


# retrieve the action
def get_action() -> actions.action_t:
    return UndoFunctionPaddingPatchAction()
